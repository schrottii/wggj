/*
 * WGGJ Framework file (C)
 * Made by:    Schrottii
 * VERSION:    v1.5.1
 * Updated on: 2025-11-01
 * 
 * DO NOT edit this file if you just copied it in -- can mess up things when updating
 * Things like images and the loading scene have to be adjusted externally
 * Everything that needs to be externally placed is provided below and in the README documentation
 */

/*
 Things to put in the index.html:

<audio id="wggjAudio" type="audio/ogg" preload="auto"></audio>
<canvas id="wggjCanvas"></canvas>
<script src="code/wggj.js"></script>

 and the respective scene loading files. if the wggj.js is not in a dir called code you may have to change the path. it should be loaded before your other scripts (such as main.js)
 Things to put in main.js or similar:
 Define every image and sound that will be used and the name of the game/app:

images = {
   placeholder: "placeholder.png",
}
audio = {
   placeholder: "placeholder.mp3",
}

wggj.config.gameName = "name of your game or app here";
wggj.config.font = "name of your font (optional)";
wggjLoadImages();
wggjLoadAudio();
wggjLoop();



 Optional: function called customWGGJLoop() that gets executed regularly within WGGJ's own loop
 Optional: function called customWGGJInit() that initializes things (such as loading a save) before WGGJ's own init
 Optional: function called loadedScene() to replace the default scene right after starting the program

 Optional: event listeners like this:

wggjCanvas.addEventListener('keydown', event => {
    if (event.code === 'Space') {
        console.log('Space pressed');
        jump();
    }
})
*/



//-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/
// VARIABLES
//-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/

// canvas
var wggjCanvas = document.getElementById("wggjCanvas");
var wggjCTX = wggjCanvas.getContext("2d");
var wggjAudio = document.getElementById("wggjAudio");

// the holy all-containing dict
var wggj = {
    time: {
        running: true,
        delta: 0,
        time: Date.now()
    },

    mouse: {
        down: false,
        x: 0,
        y: 0
    },

    canvas: {
        currentScene: "none",

        textScaling: 1,
        w: 0,
        h: 0,

        mobileWidthMulti: 1,
        pcWidthMulti: 1,
        mobileHeightMulti: 1,
        pcHeightMulti: 1,
        quadratic: false
    },

    config: {
        imageSmoothing: false,
        startScene: "mainmenu",
        font: "Times",
        gameName: "",
    },

    debug: {
        scene: false
    },

    audio: {
        // NEW
        musicPlayer: undefined,
        musicVolume: 1,
        musicMuted: false,

        soundChannels: [],
        soundVolume: 1,
        soundMuted: false,
    }
}



//-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/
// STORAGE
//-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/

// Images have to be loaded before they can be placed on a canvas
var images = {

}

// Music and sounds have to be loaded before they can be placed on a canvas
var audio = {

}

// Scenes are different parts of the visual part of the game, for example a main menu and a shop
var scenes = {

}

// This contains all objects in the current scene: image objects, buttons, etc.
var objects = {

}

// This is for animations
var animations = {

}



//-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/
// LOADING AND SETUP
//-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/

// loading stuff
var wggjLoadingImages = 0;
var wggjLoadedImages = 0;

var wggjLoadingAudio = 0;
var wggjLoadedAudio = 0;

function wggjLoadImages() {
    for (let image in images) {
        let img = new Image();
        img.src = "images/" + images[image];
        img.onload = () => {
            wggjLoadedImages++;
            if (wggjLoadingImages == wggjLoadedImages) {
                console.log("WGGJ: all images loaded");
                wggjInit(); // start game
            }
        }
        images[image] = img;
        wggjLoadingImages++;
    }
}

function wggjLoadAudio() {
    for (let sfx in audio) {
        let a = new Audio("audio/" + audio[sfx]);
        a.onloadeddata = () => {
            wggjLoadedAudio++;
            if (wggjLoadingAudio == wggjLoadedAudio) {
                console.log("WGGJ: all audio loaded");
            }
        }
        audio[sfx] = a;
        wggjLoadingAudio++;
    }
}



//-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/
// EVENT HANDLERS
//-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/

// mouse stuff
wggjCanvas.addEventListener("pointerdown", wggjEventsOnClick);
wggjCanvas.addEventListener("pointerup", wggjEventsOnPointerUp);
wggjCanvas.addEventListener("pointerleave", wggjEventsOnPointerUp);
wggjCanvas.addEventListener("pointermove", wggjEventsOnPointerMove);

function wggjEventsOnClick(e) {
    if (e.buttons != 2 || isMobile()) e.preventDefault();
    wggj.mouse.x = e.clientX - wggjCanvas.getBoundingClientRect().x;
    wggj.mouse.y = e.clientY - wggjCanvas.getBoundingClientRect().y;
    wggj.mouse.down = true;

    for (let c in objects) {
        if (objects[c] == undefined) continue;
        if (objects[c].onClick == undefined || objects[c].power == false) continue;

        if (objects[c].isHit(wggj.mouse.x, wggj.mouse.y)) {
            objects[c].onClick(c, e);
        }
    }
}

function wggjEventsOnPointerUp(e) {
    e.preventDefault();
    wggj.mouse.down = false;

    for (let c in objects) {
        if (objects[c] == undefined) continue;
        if (objects[c].onUp == undefined || objects[c].power == false) continue;

        if (objects[c].isHit(wggj.mouse.x, wggj.mouse.y)) {
            objects[c].onUp(c, e);
        }
    }
}

function wggjEventsOnPointerMove(e) {
    e.preventDefault();
    wggj.mouse.x = e.clientX - wggjCanvas.getBoundingClientRect().x;
    wggj.mouse.y = e.clientY - wggjCanvas.getBoundingClientRect().y;

    for (let c in objects) {
        if (objects[c] == undefined) continue;
        if ((objects[c].onHold == undefined && objects[c].onMouseMove == undefined) || objects[c].power == false) continue;

        if (objects[c].isHit(wggj.mouse.x, wggj.mouse.y)) {
            if (wggj.mouse.down && objects[c].onHold != undefined) objects[c].onHold(c, e);
            if (objects[c].onMouseMove != undefined) objects[c].onMouseMove(c, e);
        }
    }
}

function wggjEventsOnLoop(e) {
    for (let c in objects) {
        if (objects[c] == undefined) continue;
        if (objects[c].onHover == undefined || objects[c].power == false) continue;

        if (objects[c].isHit(wggj.mouse.x, wggj.mouse.y)) {
            objects[c].onHover(c, e);
        }
    }
}



//-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/
// SCENES
//-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/

// scene stuff
class Scene {
    constructor(init, loop) {
        this.init = init;
        this.loop = loop;
    }
}

function loadScene(sceneName) {
    if (wggj.debug.scene) console.log("loading scene: " + sceneName)
    if (scenes[sceneName] == undefined) return false;

    wggj.canvas.currentScene = sceneName;

    objects = {};

    scenes[sceneName].init();
}



//-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/
// ELEMENTS!
//-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/

// classes: Square, Image, Text, Container
class WGGJ_Square {
    constructor(x, y, w, h, color, config) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.color = color;

        // CONFIG
        this.power = isValid(config.power) ? config.power : true;
        this.clickableOnly = isValid(config.clickableOnly) ? config.clickableOnly : false;
        this.alpha = isValid(config.alpha) ? config.alpha : 1;

        this.onClick = isValid(config.onClick) ? config.onClick : undefined;
        this.onHold = isValid(config.onHold) ? config.onHold : undefined;
        this.onMouseMove = isValid(config.onMouseMove) ? config.onMouseMove : undefined;
        this.onHover = isValid(config.onHover) ? config.onHover : undefined;

        this.config = config;
    }

    currentX() {
        return ~~(wggj.canvas.w * this.x + 0.5)
            + (this.parent != undefined ? objects[this.parent].scrolledX : 0);
    }

    currentY() {
        return ~~(wggj.canvas.h * this.y + 0.5)
            + (this.parent != undefined ? objects[this.parent].scrolledY : 0);
    }

    currentW() {
        return ~~(wggj.canvas.w * this.w + 0.5);
    }

    currentH() {
        return ~~(wggj.canvas.h * this.h + 0.5);
    }

    isHit(x, y) {
        // check if a point (perhaps your mouse), with its x and y, is inside this element's boundaries
        if (x > this.currentX() && y > this.currentY()
            && x < this.currentW() + this.currentX() && y < this.currentH() + this.currentY()) {
            // is in the hitbox
            return true;
        }
        return false;
    }

    render(parented = false) {
        if (this.clickableOnly == true || this.power == false) return false;
        if (this.parent != undefined && !parented) return false;

        this.alpha = Math.min(1, Math.max(0, this.alpha));
        wggjCTX.globalAlpha = this.alpha;

        if (this.parent != undefined) {
            let containerX = objects[this.parent].x * wggj.canvas.w;
            let containerY = objects[this.parent].y * wggj.canvas.h;
            let containerWidth = objects[this.parent].w * wggj.canvas.w;
            let containerHeight = objects[this.parent].h * wggj.canvas.h;

            wggjCTX.save();
            wggjCTX.beginPath();
            wggjCTX.rect(containerX, containerY, containerWidth, containerHeight);
            wggjCTX.clip();
        }

        wggjCTX.fillStyle = this.color;
        wggjCTX.fillRect(this.currentX(), this.currentY(), this.currentW(), this.currentH());

        if (this.parent != undefined) wggjCTX.restore();
    }
}

class WGGJ_Image {
    constructor(x, y, w, h, image, config) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.image = image;

        // CONFIG
        this.quadratic = isValid(config.quadratic) ? config.quadratic : false;
        this.centered = isValid(config.centered) ? config.centered : false;
        this.power = isValid(config.power) ? config.power : true;
        this.alpha = isValid(config.alpha) ? config.alpha : 1;

        this.onClick = isValid(config.onClick) ? config.onClick : undefined;
        this.onHold = isValid(config.onHold) ? config.onHold : undefined;
        this.onMouseMove = isValid(config.onMouseMove) ? config.onMouseMove : undefined;
        this.onHover = isValid(config.onHover) ? config.onHover : undefined;

        this.config = config;
    }

    currentX() {
        let Pquadratic = this.quadratic ? wggj.canvas.w : wggj.canvas.w;
        let Pquadratic2 = this.quadratic ? wggj.canvas.h : wggj.canvas.w;
        let Pcentered = this.centered ? (Pquadratic2 * this.w / 2) : 0;
        let parentX = this.parent != undefined ? objects[this.parent].scrolledX : 0;

        return (Pquadratic * this.x) - Pcentered + parentX;
    }

    currentY() {
        let parentY = this.parent != undefined ? objects[this.parent].scrolledY : 0;

        return wggj.canvas.h * this.y + parentY;
    }

    currentW() {
        let Pquadratic2 = this.quadratic ? wggj.canvas.h : wggj.canvas.w;

        return Pquadratic2 * this.w;
    }

    currentH() {
        return wggj.canvas.h * this.h;
    }

    isHit(x, y) {
        // check if a point (perhaps your mouse), with its x and y, is inside this element's boundaries
        if (x > this.currentX() && y > this.currentY()
            && x < this.currentW() + this.currentX() && y < this.currentH() + this.currentY()) {
            // is in the hitbox
            return true;
        }
        return false;
    }

    render(parented = false) {
        // render disablers
        if (this.power == false) return false;
        if (this.parent != undefined && !parented) return false;

        this.alpha = Math.min(1, Math.max(0, this.alpha));
        wggjCTX.globalAlpha = this.alpha;

        // rotate 1/2 (beta)
        if (this.rotate) wggjCTX.translate(this.x + (this.w / 2), this.y + (this.h / 2)); wggjCTX.rotate(this.rotate);

        // my coordinates
        let renderX = this.currentX();
        let renderY = this.currentY();
        let renderW = this.currentW();
        let renderH = this.currentH();

        // snips
        let snipX = this.snip ? this.snip[0] : 0;
        let snipY = this.snip ? this.snip[1] : 0;
        let snipW = this.snip ? this.snip[2] : images[this.image].width;
        let snipH = this.snip ? this.snip[3] : images[this.image].height;

        if (this.parent != undefined) {
            let containerX = objects[this.parent].x * wggj.canvas.w;
            let containerY = objects[this.parent].y * wggj.canvas.h;
            let containerWidth = objects[this.parent].w * wggj.canvas.w;
            let containerHeight = objects[this.parent].h * wggj.canvas.h;

            wggjCTX.save();
            wggjCTX.beginPath();
            wggjCTX.rect(containerX, containerY, containerWidth, containerHeight);
            wggjCTX.clip();

            let overlapX = Math.max(0, containerX - renderX);
            let overlapY = Math.max(0, containerY - renderY);
            let visibleWidth = Math.min(renderW, containerX + containerWidth - renderX);
            let visibleHeight = Math.min(renderH, containerY + containerHeight - renderY);

            snipX += overlapX * (snipW / renderW);
            snipY += overlapY * (snipH / renderH);
            snipW *= visibleWidth / renderW;
            snipH *= visibleHeight / renderH;

            renderX = Math.max(renderX, containerX);
            renderY = Math.max(renderY, containerY);
            renderW = visibleWidth;
            renderH = visibleHeight;
        }

        if (this.snip || this.parent) wggjCTX.drawImage(images[this.image], snipX, snipY, snipW, snipH, renderX, renderY, renderW, renderH);
        else wggjCTX.drawImage(images[this.image], renderX, renderY, renderW, renderH);

        if (this.parent != undefined) wggjCTX.restore();

        // rotate 2/2 (beta)
        if (this.rotate) wggjCTX.translate(-this.x - (this.w / 2), -this.y - (this.h / 2)); wggjCTX.rotate(0);
    }
}

class WGGJ_Text {
    constructor(x, y, text, config) {
        this.x = x;
        this.y = y;
        this.text = text;

        // CONFIG
        this.color = isValid(config.color) ? config.color : "black";
        this.size = isValid(config.size) ? config.size : "12";
        this.align = isValid(config.align) ? config.align : "center";
        this.power = isValid(config.power) ? config.power : true;
        this.noScaling = isValid(config.noScaling) ? config.noScaling : false;
        this.alpha = isValid(config.alpha) ? config.alpha : 1;

        this.config = config;
    }

    getScaling() {
        // includes size, textscaling/noscaling, rounding for optimization
        let scaling = 0;
        if (this.noScaling) scaling = this.size;
        else scaling = this.size * wggj.canvas.textScaling;
        if (scaling > 60) scaling = ~~(scaling + 0.5);
        return scaling;
    }

    // placeholders
    currentX() {
        return 0;
    }

    currentY() {
        return 0;
    }

    currentW() {
        return 0;
    }

    currentH() {
        return 0;
    }

    render(parented = false) {
        if (this.power == false) return false;
        if (this.parent != undefined && !parented) return false;

        this.alpha = Math.min(1, Math.max(0, this.alpha));
        wggjCTX.globalAlpha = this.alpha;

        wggjCTX.fillStyle = this.color;
        wggjCTX.font = this.getScaling() + "px " + wggj.config.font;
        wggjCTX.textBaseline = "bottom";
        wggjCTX.textAlign = this.align;

        let renderX = wggj.canvas.w * this.x;
        let renderY = wggj.canvas.h * this.y;

        if (this.parent != undefined) {
            let containerX = objects[this.parent].x * wggj.canvas.w;
            let containerY = objects[this.parent].y * wggj.canvas.h;
            let containerWidth = objects[this.parent].w * wggj.canvas.w;
            let containerHeight = objects[this.parent].h * wggj.canvas.h;

            renderX += objects[this.parent].scrolledX;
            renderY += objects[this.parent].scrolledY;

            wggjCTX.save();
            wggjCTX.beginPath();
            wggjCTX.rect(containerX, containerY, containerWidth, containerHeight);
            wggjCTX.clip();
        }

        if (this.text.includes("\n")) {
            let splitText = this.text.split("\n");
            for (let sT = 0; sT < splitText.length; sT++) {
                wggjCTX.fillText(splitText[sT], renderX, renderY + sT * this.getScaling());
            }
        }
        else {
            // single line text
            wggjCTX.fillText(this.text, renderX, renderY);
        }

        if (this.parent != undefined) wggjCTX.restore();
    }
}

class WGGJ_Container {
    constructor(name, x, y, w, h, config, children) {
        this.name = name;
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.config = config;
        this.children = children;

        this.recentMouseX = 0;
        this.recentMouseY = 0;
        this.scrolledX = 0;
        this.scrolledY = 0;

        // CONFIG
        this.color = isValid(config.color) ? config.color : false;
        this.XScroll = isValid(config.XScroll) ? config.XScroll : false;
        this.YScroll = isValid(config.YScroll) ? config.YScroll : false;
        this.XScrollMod = isValid(config.XScrollMod) ? config.XScrollMod : 1;
        this.YScrollMod = isValid(config.YScrollMod) ? config.YScrollMod : 1;
        this.XLimit = isValid(config.XLimit) ? config.XLimit : [0, 0]; // left right
        this.YLimit = isValid(config.YLimit) ? config.YLimit : [0, 0]; // up down
        this.limitEffect = isValid(config.limitEffect) ? config.limitEffect : false;
    }

    onClick(c, e) {
        // set the start pos of a drag
        if (isNaN(e.clientX) || isNaN(e.clientY)) return false;
        if (this.XScroll == true) this.recentMouseX = e.clientX - wggjCanvas.getBoundingClientRect().x;
        if (this.YScroll == true) this.recentMouseY = e.clientY - wggjCanvas.getBoundingClientRect().y;
    }

    onHold(c, e) {
        // add the pos while dragging - done here and not in onUp so you can see it while dragging
        if (isNaN(e.clientX) || isNaN(e.clientY) || (this.recentMouseX == 0 && this.recentMouseY == 0)) return false;

        if (this.XScroll == true) {
            this.scrolledX = Math.min((this.XLimit[0] != 0 ? this.XLimit[0] : 1e7) * wggj.canvas.w,
                Math.max((this.XLimit[1] != 0 ? -this.XLimit[1] : -1e7) * wggj.canvas.w,
                    this.scrolledX + (e.clientX - wggjCanvas.getBoundingClientRect().x - this.recentMouseX) * this.XScrollMod));

        }
        if (this.YScroll == true) {
            this.scrolledY = Math.min((this.YLimit[0] != 0 ? this.YLimit[0] : 1e7) * wggj.canvas.h,
                Math.max((this.YLimit[1] != 0 ? -this.YLimit[1] : -1e7) * wggj.canvas.h,
                    this.scrolledY + (e.clientY - wggjCanvas.getBoundingClientRect().y - this.recentMouseY) * this.YScrollMod));
        }

        this.recentMouseX = e.clientX;
        this.recentMouseY = e.clientY;
    }

    resetScroll() {
        this.recentMouseX = 0;
        this.recentMouseY = 0;
        this.scrolledX = 0;
        this.scrolledY = 0;
    }

    currentX() {
        return wggj.canvas.w * this.x;
    }

    currentY() {
        return wggj.canvas.h * this.y;
    }

    currentW() {
        return wggj.canvas.w * this.w;
    }

    currentH() {
        return wggj.canvas.h * this.h;
    }

    isHit(x, y) {
        // check if a point (perhaps your mouse), with its x and y, is inside this element's boundaries
        if (x > this.currentX() && y > this.currentY()
            && x < this.currentW() + this.currentX() && y < this.currentH() + this.currentY()) {
            // is in the hitbox
            return true;
        }
        return false;
    }

    render() {
        if (this.color != false) {
            // background color
            wggjCTX.fillStyle = this.color;
            wggjCTX.fillRect(this.currentX(), this.currentY(), this.currentW(), this.currentH());
        }

        if (this.limitEffect != false && wggj.mouse.down) {
            wggjCTX.fillStyle = this.limitEffect == true ? "white" : this.limitEffect;

            if (this.scrolledX == this.XLimit[0] * wggj.canvas.w) wggjCTX.fillRect(this.currentX(), this.currentY(), 0.004 * wggj.canvas.w, this.currentH());
            if (this.scrolledX == -this.XLimit[1] * wggj.canvas.w) wggjCTX.fillRect(this.currentX() + this.currentW() - 0.004 * wggj.canvas.w, this.currentY(), 0.004 * wggj.canvas.w, this.currentH());
            if (this.scrolledY == this.YLimit[0] * wggj.canvas.h) wggjCTX.fillRect(this.currentX(), this.currentY(), this.currentW(), 0.004 * wggj.canvas.h);
            if (this.scrolledY == -this.YLimit[1] * wggj.canvas.h) wggjCTX.fillRect(this.currentX(), this.currentY() + this.currentH() - 0.004 * wggj.canvas.h, this.currentW(), 0.004 * wggj.canvas.h);
        }

        for (let child in this.children) {
            let thisChild = objects[this.children[child]];

            // set this container as the child's parent
            if (thisChild.parent == undefined) thisChild.parent = this.name;

            // render it from here, so it gets rendered on top
            // in their individual render functions there's stuff to prevent duplicate rendering
            thisChild.render(true);
        }
    }
}

class WGGJ_Animation {
    constructor(name, target, effect, maxDur, keep) {
        this.name = name;
        this.target = target;
        this.effect = effect;
        this.maxDur = maxDur; // if dur is 0 it has no fixed duration
        this.keep = keep;
        this.dur = 0;

        this.targetPrestate = Object.assign({}, objects[target]);
        this.tps = this.targetPrestate;
        this.pct = 0;
    }

    kill(i = this.name) {
        if (this.dur == 0 && this.maxDur == 0) return false;
        if (!this.keep && isValid(this.targetPrestate) && objects[this.target] != undefined) {
            for (let e in this.targetPrestate) {
                objects[this.target][e] = this.targetPrestate[e];
            }
        }
        delete animations[i];
        return true;
    }

    durationTick(delta, i) {
        this.dur += delta;
        this.pct = this.dur / this.maxDur;
        if (this.maxDur != 0 && this.dur >= this.maxDur) {
            // suicide
            this.kill(i);
        }
    }

    animationTick(delta) {
        if (objects[this.target] == undefined) this.kill();
        else if (typeof (this.effect) == "function") {
            this.effect(objects[this.target], delta, this);
        }
    }
}



//-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/
// FUNCTIONS TO CREATE THE ELEMENTS
//-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/

// create functions: createSquare, createImage, createText, createClickable, createButton, createContainer
function createSquare(name, x, y, w, h, color, config = {}) {
    if (objects[name] == undefined) {
        objects[name] = new WGGJ_Square(x, y, w, h, color, config);
        return name;
    }
    return "";
}

function createImage(name, x, y, w, h, image, config = {}) {
    if (objects[name] == undefined) {
        objects[name] = new WGGJ_Image(x, y, w, h, image, config);
        return name;
    }
    return "";
}

function createText(name, x, y, text, config = {}) {
    if (objects[name] == undefined) {
        objects[name] = new WGGJ_Text(x, y, text, config);
        return name;
    }
    return "";
}

function createClickable(clickableName, x, y, w, h, onClick, config = {}) {
    if (objects[clickableName] == undefined) {
        objects[clickableName] = new WGGJ_Square(x, y, w, h, "white", config);
        objects[clickableName].clickableOnly = true;
        objects[clickableName].onClick = onClick;
        return name;
    }
    return "";
}

function createButton(clickableName, x, y, w, h, color, onClick, config = {}) {
    if (objects[clickableName] == undefined) {
        if (color.substr(0, 1) == "#") objects[clickableName] = new WGGJ_Square(x, y, w, h, color, config);
        else objects[clickableName] = new WGGJ_Image(x, y, w, h, color, config);
        objects[clickableName].onClick = onClick;
        return clickableName;
    }
    return "";
}

function createContainer(name, x, y, w, h, config, children) {
    if (objects[name] == undefined) {
        objects[name] = new WGGJ_Container(name, x, y, w, h, config, children);
        return name;
    }
    return "";
}



//-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/
// ANIMATIONS
//-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/

function createAnimation(name, target, effect, dur = 0, keep = false) {
    if (animations[name] == undefined) {
        animations[name] = new WGGJ_Animation(name, target, effect, dur, keep);
        return name;
    }
    return "";
}

function killAnimation(name) {
    if (animations[name] != undefined) {
        animations[name].kill();
        return true;
    }
    return false;
}

const wAnis = {
    empty: (t, d, a) => {  },
    fadeIn: (t, d, a) => { t.alpha = a.pct; },
    fadeOut: (t, d, a) => { t.alpha = 1 - a.pct; },
    clickBounce: (t, d, a) => { t.w = t.h = a.tps.w * a.pct; t.y = a.tps.y + 0.1 - 0.1 * a.pct; },
    clickPretty: (t, d, a) => { t.w = t.h = a.tps.w * a.pct; t.y = a.tps.y + 0.1 - 0.1 * a.pct; t.alpha = a.pct / 2; },

    moveIn: {
        top: (t, d, a) => { t.y = Math.min(a.tps.y, 0 - a.tps.h + (a.tps.y + a.tps.h) * a.pct); },
        bottom: (t, d, a) => { t.y = Math.max(a.tps.y, 1 - a.tps.y * a.pct); },
        left: (t, d, a) => { t.x = Math.min(a.tps.x, 0 - a.tps.w + (a.tps.x + a.tps.w) * a.pct); },
        right: (t, d, a) => { t.x = Math.max(a.tps.x, 1 - a.tps.x * a.pct); },
    },
    moveOut: {
        top: (t, d, a) => { t.y = Math.min(a.tps.y, 0 - a.tps.h + (a.tps.y + a.tps.h) * (1 - a.pct)); },
        bottom: (t, d, a) => { t.y = Math.max(a.tps.y, 1 + a.tps.h - a.tps.y * (1 - a.pct)); },
        left: (t, d, a) => { t.x = Math.min(a.tps.x, 0 - a.tps.w + (a.tps.x + a.tps.w) * (1 - a.pct)); },
        right: (t, d, a) => { t.x = Math.max(a.tps.x, 1 + a.tps.w - a.tps.x * (1 - a.pct)); },
    }
};



//-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/
// AUDIO: MUSIC & SOUNDS
//-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/

function wggjAudioInit() {
    try {
        if (audio == undefined || audio.length < 1) return false;
    }
    catch {
        return false;
    }

    // generate audio tag for music
    /*
    wggj.audio.musicPlayer = new Audio();
    let srcSoundPlayer = document.createElement("source");
    srcSoundPlayer.type = "audio/ogg";
    srcSoundPlayer.preload = "auto";
    srcSoundPlayer.src = "audio/" + audio[Object.keys(audio)[0]];
    wggj.audio.musicPlayer = srcSoundPlayer;
    */
    wggj.audio.musicPlayer = document.getElementById("wggjAudio");
    wggj.audio.musicPlayer.loop = true;

    // Generate 16 sound channels
    for (s = 0; s < 16; s++) {
        wggj.audio.soundChannels[s] = new Audio();

        wggj.audio.soundChannels[s].type = "audio/mpeg";
        wggj.audio.soundChannels[s].preload = "auto";
        wggj.audio.soundChannels[s].src = audio[Object.keys(audio)[0]];
    }
}

// MUSIC
function audioPlayMusic(name,/* intro = "none"*/) {
    // plays a song, if it has an intro it plays that first and then the main song (unless interrupted)

    // prevention if it does not exist
    if (wggj.audio.musicPlayer == undefined) return false;
    if (audio[name] == undefined || audio[name].src == undefined) {
        console.log("Music undefined: " + name);
        return false;
    }

    let musicPlayer = wggj.audio.musicPlayer;

    musicPlayer.volume = wggj.audio.musicVolume;
    musicPlayer.muted = wggj.audio.musicMuted;

    // play in the music channel (there is only one)
    if (musicPlayer.volume > 0 && musicPlayer.volume <= 1) {
        if (audio[name].src != musicPlayer.src) {
            if (true/*intro == "none"*/) {
                // NO INTRO
                //playAfterIntro = "none"; // play the loop, nothing after that
                musicPlayer.src = audio[name].src;
                musicPlayer.loop = true;
                //if (!game.jukebox.includes(name)) game.jukebox.push(name);
            }
            else {
                // THERE IS AN INTRO, play it first
                //playAfterIntro = name;
                //musicPlayer.src = audio[intro].src;
                //musicPlayer.loop = false;
            }
        }
        musicPlayer.play();
    }
}

/*
function introToLoop() {
    if (playAfterIntro == "none" || playAfterIntro == undefined) return false;

    let musicPlayer = wggj.audio.musicPlayer;

    // prevention if it does not exist
    if (wggj.audio.musicPlayer == undefined) return false;
    if (audio[playAfterIntro] == undefined || audio[playAfterIntro].src == undefined) {
        console.log("Intro2Loop undefined: " + playAfterIntro);
        return false;
    }

    // transition from an intro track to a loop track
    if (musicPlayer.currentTime >= musicPlayer.duration) {
        musicPlayer.src = audio[playAfterIntro].src;
        playAfterIntro = "none";

        //if (!game.jukebox.includes(name)) game.jukebox.push(name);
        musicPlayer.loop = true;
        musicPlayer.play();
    }

}
*/

// play a sound - now supports sound channels!
function audioPlaySound(name) {
    // prevention if it does not exist
    if (wggj.audio.soundChannels.length == 0) return false;
    if (audio[name] == undefined || audio[name].src == undefined) {
        console.log("Sound undefined: " + name);
        return false;
    }

    let s = 0;
    let p;
    while (s < 16) { // If all 16 are occupied, it won't play any sound
        p = wggj.audio.soundChannels[s];
        if (p.currentTime >= p.duration || p.src == "" || isNaN(p.duration)) {
            // update volume & muted
            p.volume = wggj.audio.soundVolume;
            p.muted = wggj.audio.soundMuted;

            // update source and play
            p.src = audio[name].src;
            p.play();
            return true;
        }
        else { // Channel is occupied. (Angry sound channel sounds)
            s += 1;
        }
    }
    // could not play sound
    return false;
}

function audioChangeVolume(type, vol, unmute = false) {
    if (type == "music") {
        wggj.audio.musicVolume = vol;
        if (unmute && vol > 0) wggj.audio.musicMuted = false;

        // update volume & muted
        wggj.audio.musicPlayer.volume = wggj.audio.musicVolume;
        wggj.audio.musicPlayer.muted = wggj.audio.musicMuted;
    }
    if (type == "sound" || type == "sounds") {
        wggj.audio.soundVolume = vol;
        if (unmute && vol > 0) wggj.audio.soundMuted = false;

        // update volume & muted
        for (s = 0; s < 16; s++) {
            wggj.audio.soundChannels[s].volume = wggj.audio.soundVolume;
            wggj.audio.soundChannels[s].muted = wggj.audio.soundMuted;
        }
    }
}

function audioPause(type) {
    if (type == "music") {
        wggj.audio.musicPlayer.pause();
    }
    if (type == "sound" || type == "sounds") {
        for (s = 0; s < 16; s++) {
            wggj.audio.soundChannels[s].pause();
        }
    }
}



//-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/
// VARIOUS FUNCTIONS
//-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/

function wggjUpdateTextScaling() {
    // can be replaced if you want different scaling
    // but this one is 0.5 at 480 width, 0.4375 at 360 and 1 at 1440... roughly what you want.
    // also popular: wggj.canvas.textScaling = isMobile() ? 0.5 : 1;
    wggj.canvas.textScaling = 0.5 + 0.5 * (wggj.canvas.w / 1920);
}

function isMobile() {
    return /Mobi/i.test(window.navigator.userAgent) || wggj.canvas.w <= 640;
}

function isValid(v) {
    if (v == undefined || v === "" || (v.length != undefined && v.length == 0)) return false;
    return true;
}



//-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/
// LOOP AND INIT
//-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/-*/

// wggjLoop
function wggjLoop() {
    // The game's main loop
    // This part just does the wggj side of things, to add your own loop, define a function called customWGGJLoop()

    if (!wggj.time.running) return false; // can be used to turn off the loop. start it again by calling it

    // Tick wggj.time.time
    wggj.time.delta = Date.now() - wggj.time.time;
    wggj.time.time = Date.now();

    wggjEventsOnLoop();

    // Resize the wggjCanvas
    if (window.innerWidth <= 480) {
        // mobile
        wggjCanvas.style.width = (wggj.canvas.w = wggjCanvas.width = window.innerWidth * wggj.canvas.mobileWidthMulti) + "px";
        wggjCanvas.style.height = (wggj.canvas.h = wggjCanvas.height = (wggj.canvas.quadratic ? window.innerWidth : window.innerHeight) * wggj.canvas.mobileHeightMulti) + "px";
    }
    else {
        // PC
        wggjCanvas.style.width = (wggj.canvas.w = wggjCanvas.width = window.innerWidth * wggj.canvas.pcWidthMulti) + "px";
        wggjCanvas.style.height = (wggj.canvas.h = wggjCanvas.height = (wggj.canvas.quadratic ? window.innerWidth : window.innerHeight) * wggj.canvas.pcHeightMulti) + "px";
    }

    wggjUpdateTextScaling();
    wggjCTX.imageSmoothingEnabled = wggj.config.imageSmoothing;

    // Your own custom loop function
    if (typeof (customWGGJLoop) != "undefined") customWGGJLoop(wggj.time.delta);

    if (wggj.canvas.currentScene != "none") {
        // render the current scene
        scenes[wggj.canvas.currentScene].loop(wggj.time.delta / 1000);

        // animations
        for (a in animations) {
            animations[a].animationTick(wggj.time.delta / 1000);
            if (isValid(animations[a])) animations[a].durationTick(wggj.time.delta / 1000, a);
        }
        // normal objects
        for (o in objects) {
            if (!objects[o].config?.foreground) objects[o].render();
        }
        // foreground objects
        for (o in objects) {
            if (objects[o].config?.foreground) objects[o].render();
        }
    }
    else {
        // Loading images / no scene selected
        // if you want to adjust it, create your own function called loadedScene()
        if (typeof (loadedScene) != "undefined") loadedScene();
        else wggjLoadedScene();
    }

    requestAnimationFrame(wggjLoop);
}

function wggjLoadedScene() {
    wggjCTX.fillStyle = "black";
    wggjCTX.fillRect(0, 0, wggj.canvas.w, wggj.canvas.h);

    wggjCTX.font = "40px " + wggj.config.font;
    wggjCTX.fillStyle = "white";
    wggjCTX.textBaseline = "bottom";
    wggjCTX.textAlign = "center";

    wggjCTX.fillText(wggj.config.gameName, wggj.canvas.w / 2, wggj.canvas.h / 4);
    if (wggjLoadedImages == wggjLoadingImages) wggjCTX.fillText("Click to start!", wggj.canvas.w / 2, wggj.canvas.h / 2);
    else wggjCTX.fillText("Loaded: " + wggjLoadedImages + "/" + wggjLoadingImages, wggj.canvas.w / 2, wggj.canvas.h / 2);
}

// initialize the game
wggjCTX.imageSmoothingEnabled = false;

function wggjInit() {
    // Your own custom init function
    if (typeof (customWGGJInit) != "undefined") customWGGJInit();

    wggjAudioInit();

    // creates a clickable that spans the entire screen, click to start
    createClickable("startTheGame", 0, 0, 1, 1, () => {
        loadScene(wggj.config.startScene != undefined ? wggj.config.startScene : "mainmenu");
    });
}